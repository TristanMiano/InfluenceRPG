PROMPT FOR AI MODEL:

You are about to read a detailed overview of a software project. Please read 
everything in the following text and act as a helpful software engineering assistant. This overview itself is generated by one of the files which will be described below.

At the end of the overview, there will be a list of next steps for implementation. Please tailor your response for these steps. Generally, if more than one step is listed, focus on the first one only in your first response. The user will probably request the subsequent steps later.

If you can't find any next steps for the project listed at the bottom of the file, please do your best to look for mistakes, errors, discrepancies, or ways to clean up and refine the project, and decide yourself what should be considered high priority, and include that in your first response.

--------------------------------------------------------------------------------

=== Directory Structure ===
Directory: .
  File: generate_object_templates.py | Type: .py
  File: generate_project_overview.py | Type: .py
  File: project_query.py | Type: .py
  File: README.md | Type: .md
  File: requirements_autogenerated.txt | Type: .txt
Directory: config
  File: llm_config.json | Type: .json
  File: README.md | Type: .md
Directory: design
  File: function_calling.md | Type: .md
  File: README.md | Type: .md
Directory: drafts
  File: README.md | Type: .md
Directory: drafts\character
  File: attributes_draft_1.txt | Type: .txt
  File: classes_draft_1.txt | Type: .txt
  File: risk_categories_draft_1.txt | Type: .txt
Directory: src
  File: README.md | Type: .md

=== Consolidated Documentation ===

=== Content of ./generate_object_templates.py ===
#!/usr/bin/env python3
"""
generate_object_templates.py

This script searches the 'reference' directory for text-based materials,
reads each file, and uses the Gemini 2.0 Flash API (configured in config/llm_config.json)
to analyze the content. Gemini is prompted to recognize objects such as types of people,
professions, titles (military or noble), military hierarchy units (e.g., platoons, brigades),
ships, weapons, place names, vehicles, items, forts, towns, etc. For each file,
it returns a JSON array of object templates. The final output is saved in 'object_templates.json'.
"""

import os
import json
import argparse
from pathlib import Path

def load_config():
    """
    Loads Gemini configuration from config/llm_config.json.
    """
    config_path = Path("config") / "llm_config.json"
    try:
        with open(config_path, 'r', encoding='utf-8') as f:
            config = json.load(f)
        return config
    except Exception as e:
        print(f"Error loading config from {config_path}: {e}")
        return {}

def traverse_reference_directory(ref_dir):
    """
    Walk through the reference directory and collect all text-based files.
    """
    ref_files = []
    for root, dirs, files in os.walk(ref_dir):
        for file in files:
            if file.endswith(('.txt', '.md')):
                ref_files.append(Path(root) / file)
    return ref_files

def read_file(file_path):
    """
    Reads the content of a file.
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            return f.read()
    except Exception as e:
        print(f"Error reading {file_path}: {e}")
        return ""

def call_gemini_generate_json(prompt, config):
    """
    Calls the Gemini 2.0 Flash API using the google.genai package.
    If the API is unavailable, returns a simulated empty JSON array.
    """
    retries = 3  # Maximum number of retries on rate limit errors
    while retries > 0:
        try:
            from google import genai
            api_key = config.get("GEMINI_API_KEY")
            model = config.get("DEFAULT_MODEL", "gemini-2.0-flash")
            client = genai.Client(api_key=api_key)
            response = client.models.generate_content(
                model=model,
                contents=[prompt]
            )
            json_output = response.text.strip()
            # Clean up potential markdown formatting (e.g., ```json ... ```)
            if json_output.startswith("```json"):
                json_output = json_output[len("```json"):].strip()
            if json_output.endswith("```"):
                json_output = json_output[:-3].strip()
            return json_output
        except ImportError:
            print("Gemini API package not found. Simulating output.")
            json_output = "[]"
            return json_output
        except Exception as e:
            error_message = str(e).lower()
            # Check for rate limit error indicators: 429 status code or RESOURCE_EXHAUSTED keyword
            if "429" in error_message or "resource_exhausted" in error_message:
                print("Rate limit exceeded. Waiting 60 seconds before retrying...")
                import time
                time.sleep(60)
                retries -= 1
                continue  # Try the request again
            else:
                print("Error calling Gemini API:", e)
                json_output = "[]"
                return json_output


def generate_object_templates_for_file(content, file_path, config):
    """
    Constructs a prompt for Gemini to extract recognized objects from the content,
    then calls Gemini and parses the resulting JSON.
    """
    prompt = f"""
Analyze the following reference material extracted from the file: {file_path}.
Identify any objects that fall under these categories:
- Types of people, professions, titles (military or noble),
- Military hierarchy units (e.g., platoons, brigades),
- Ships, weapons, place names, vehicles, items, forts, towns, etc.
For each recognized object, output a JSON object with the following keys:
  - "category": the object category (e.g., "ship", "weapon", "town", etc.)
  - "name": the name of the object
  - "attributes": an object containing any additional details (if available)
Output the result as a JSON array. If no objects are found, output an empty JSON array.

Content:
\"\"\"{content}\"\"\"
"""
    json_output = call_gemini_generate_json(prompt, config)
    try:
        templates = json.loads(json_output)
    except json.JSONDecodeError:
        print(f"Failed to decode JSON output for file {file_path}.")
        print(json_output)
        templates = []
    return templates

def main():
    parser = argparse.ArgumentParser(
        description="Generate JSON templates for objects recognized in reference materials using Gemini 2.0 Flash."
    )
    parser.add_argument("--reference_dir", type=str, default="reference",
                        help="Directory containing reference materials.")
    parser.add_argument("--output", type=str, default="object_templates.json",
                        help="Output JSON file to store object templates.")
    args = parser.parse_args()

    # Load configuration for Gemini
    config = load_config()
    ref_dir = Path(args.reference_dir)
    ref_files = traverse_reference_directory(ref_dir)

    all_templates = {}

    for file_path in ref_files:
        print(f"Processing {file_path}...")
        content = read_file(file_path)
        if not content.strip():
            continue
        templates = generate_object_templates_for_file(content, file_path, config)
        all_templates[str(file_path)] = templates

    # Write the collected JSON templates to the output file
    with open(args.output, 'w', encoding='utf-8') as f:
        json.dump(all_templates, f, indent=2)
    print(f"Object templates generated and saved to {args.output}")

if __name__ == "__main__":
    main()


=== Content of ./generate_project_overview.py ===
#!/usr/bin/env python3
"""
generate_project_overview.py

Usage:
  python generate_project_overview.py
     -> Generates 'project_overview.txt' with the full code for text files,
        except for skipping listing files inside data/ directories.

  python generate_project_overview.py --short
     -> Generates 'project_overview.txt' with only function/ class signatures and
        docstrings for Python files, no full code included.

  python generate_project_overview.py --short path/to/exclude1.py path/to/exclude2.txt
     -> When using the --short flag, the additional file paths passed as arguments
        will be excluded from shortening and will be output in full.

  python generate_project_overview.py --skip path/to/skipDir path/to/skipFile.txt
     -> Skips the specified directories or files entirely. This flag can be used with
        or without the other flags.

Additionally, this script parses Python files to extract third-party imports
and writes them to 'requirements_autogenerated.txt'.
"""

import os
import sys
import ast
import argparse
from pathlib import Path

# A naive list of known standard library modules we skip from "requirements".
STANDARD_LIBS = {
    "abc", "argparse", "ast", "asyncio", "base64", "binascii", "bisect", "builtins", "calendar",
    "collections", "concurrent", "contextlib", "copy", "csv", "ctypes", "datetime", "decimal",
    "difflib", "dis", "distutils", "email", "enum", "errno", "faulthandler", "filecmp", "fileinput",
    "fnmatch", "fractions", "functools", "gc", "getopt", "getpass", "gettext", "glob", "gzip", "hashlib",
    "heapq", "hmac", "http", "imaplib", "imp", "importlib", "inspect", "io", "ipaddress", "itertools",
    "json", "logging", "lzma", "math", "multiprocessing", "numbers", "operator", "os", "pathlib",
    "pickle", "platform", "plistlib", "pprint", "queue", "random", "re", "runpy", "sched", "secrets",
    "select", "shlex", "shell", "shutil", "signal", "site", "smtp", "smtplib", "socket", "socketserver",
    "sqlite3", "ssl", "stat", "statistics", "string", "struct", "subprocess", "sys", "tempfile", "termios",
    "textwrap", "threading", "time", "timeit", "tkinter", "traceback", "types", "typing", "unittest",
    "urllib", "uuid", "venv", "warnings", "wave", "weakref", "webbrowser", "xml", "xmlrpc", "zipfile", "zipimport"
}

PROMPT_TEXT = """PROMPT FOR AI MODEL:

You are about to read a detailed overview of a software project. Please read 
everything in the following text and act as a helpful software engineering assistant. This overview itself is generated by one of the files which will be described below.

At the end of the overview, there will be a list of next steps for implementation. Please tailor your response for these steps. Generally, if more than one step is listed, focus on the first one only in your first response. The user will probably request the subsequent steps later.

If you can't find any next steps for the project listed at the bottom of the file, please do your best to look for mistakes, errors, discrepancies, or ways to clean up and refine the project, and decide yourself what should be considered high priority, and include that in your first response.

--------------------------------------------------------------------------------
"""

def is_text_file(file_path):
    """
    Check if a file is a text file based on its extension.
    """
    text_extensions = {
        '.txt', '.md', '.rst', '.py', '.java', '.js', '.ts', '.cpp', '.c',
        '.cs', '.html', '.css', '.xml', '.yaml', '.yml', '.sh', '.bat',
        '.go', '.rb', '.php', '.swift', '.kt', '.scala', '.pl', '.sql'
    }
    return file_path.suffix.lower() in text_extensions

def get_file_type(file_path):
    """
    Determine the file type based on its extension.
    """
    return file_path.suffix.lower() if file_path.suffix else 'No Extension'

def extract_functions_and_docstrings(file_content):
    """
    Parse Python code with AST, returning a string with
    module-level docstring, class names, function names,
    and any docstrings. Used for the --short flag.
    """
    try:
        tree = ast.parse(file_content)
    except SyntaxError:
        return ""

    lines = []
    module_docstring = ast.get_docstring(tree)
    if module_docstring:
        lines.append(f'Module Docstring:\n"""{module_docstring}"""\n')

    for node in tree.body:
        if isinstance(node, ast.FunctionDef):
            lines.append(f"def {node.name}(...):")
            func_doc = ast.get_docstring(node)
            if func_doc:
                lines.append(f'    """{func_doc}"""')
            lines.append("")

        elif isinstance(node, ast.ClassDef):
            lines.append(f"class {node.name}(...):")
            class_doc = ast.get_docstring(node)
            if class_doc:
                lines.append(f'    """{class_doc}"""')
            for subnode in node.body:
                if isinstance(subnode, ast.FunctionDef):
                    lines.append(f"    def {subnode.name}(...):")
                    method_doc = ast.get_docstring(subnode)
                    if method_doc:
                        lines.append(f'        """{method_doc}"""')
            lines.append("")

    return "\n".join(lines)

def parse_imports_from_python(file_content):
    """
    Parse Python imports using AST, returning a set of top-level modules
    that might be external dependencies.
    """
    try:
        tree = ast.parse(file_content)
    except SyntaxError:
        return set()

    imported_modules = set()
    for node in ast.walk(tree):
        if isinstance(node, ast.Import):
            for alias in node.names:
                imported_modules.add(alias.name.split('.')[0])
        elif isinstance(node, ast.ImportFrom):
            if node.module:
                imported_modules.add(node.module.split('.')[0])
    return imported_modules

def is_standard_library(module_name):
    """
    Very naive check if a module name is in our known standard libraries set.
    """
    return module_name in STANDARD_LIBS

def traverse_directory(root_path, short_version=False, exclude_files=None, skip_paths=None):
    """
    Traverse the directory and collect:
      - directory structure (skipping file listings under data/ and any paths specified in skip_paths),
      - file contents (full or short version),
      - third-party imports from Python files.
    """
    directory_structure = []
    relevant_contents = []
    third_party_libraries = set()

    readme_extensions = {'.md', '.markdown', '.txt'}
    code_extensions = {
        '.py', '.java', '.js', '.ts', '.cpp', '.c', '.cs', '.html', '.css',
        '.xml', '.yaml', '.yml', '.sh', '.bat', '.go', '.rb',
        '.php', '.swift', '.kt', '.scala', '.pl', '.sql'
    }
    documentation_extensions = {'.md', '.markdown', '.txt', '.rst'}

    if exclude_files is None:
        exclude_files = []
    if skip_paths is None:
        skip_paths = []

    # Normalize exclude and skip paths to posix-style strings for reliable comparison.
    normalized_exclude = {Path(f).as_posix() for f in exclude_files}
    normalized_skip = {Path(f).as_posix() for f in skip_paths}

    for dirpath, dirnames, filenames in os.walk(root_path):
        # Skip hidden directories.
        dirnames[:] = [d for d in dirnames if not d.startswith('.')]

        relative_dir = os.path.relpath(dirpath, root_path)
        relative_dir_posix = Path(relative_dir).as_posix()

        # Skip this directory if it or any parent directory is in the skip list.
        if any(relative_dir_posix == skip_item or relative_dir_posix.startswith(skip_item + "/") for skip_item in normalized_skip):
            continue

        directory_structure.append(f"Directory: {relative_dir}")

        # Skip listing files if under data/
        if relative_dir.startswith('data'):
            continue

        # Optionally, modify dirnames in-place to skip subdirectories matching skip paths.
        dirnames[:] = [d for d in dirnames if not any(
            (Path(relative_dir, d).as_posix() == skip_item or Path(relative_dir, d).as_posix().startswith(skip_item + "/"))
            for skip_item in normalized_skip
        )]

        for filename in filenames:
            file_path = Path(dirpath) / filename
            if file_path.name.startswith('.'):
                continue

            # Build a relative file identifier (e.g., "src/file.py")
            relative_file = Path(relative_dir) / filename
            relative_file_posix = relative_file.as_posix()

            # Skip this file entirely if it is in the skip list.
            if any(relative_file_posix == skip_item or relative_file_posix.startswith(skip_item + "/")
                   for skip_item in normalized_skip):
                continue

            file_type = get_file_type(file_path)
            directory_structure.append(f"  File: {filename} | Type: {file_type}")

            # Determine if the file should be shortened.
            should_shorten = short_version and (relative_file_posix not in normalized_exclude)

            # If it's a recognized text file, try reading it.
            if (is_text_file(file_path)
                and (file_path.suffix.lower() in readme_extensions
                     or file_path.suffix.lower() in code_extensions
                     or file_path.suffix.lower() in documentation_extensions)):
                try:
                    content = file_path.read_text(encoding='utf-8')

                    # If it's a Python file, parse imports.
                    if file_path.suffix.lower() == '.py':
                        imports_in_file = parse_imports_from_python(content)
                        for lib in imports_in_file:
                            if not is_standard_library(lib):
                                third_party_libraries.add(lib)

                    # For Python files, if short_version is True and file is not excluded, shorten its content.
                    if file_path.suffix.lower() == '.py' and should_shorten:
                        extracted = extract_functions_and_docstrings(content)
                        if extracted.strip():
                            header = f"\n=== Functions & Docstrings in {relative_dir}/{filename} ===\n"
                            relevant_contents.append(header + extracted)
                    else:
                        header = f"\n=== Content of {relative_dir}/{filename} ===\n"
                        relevant_contents.append(header + content)

                except Exception as e:
                    print(f"Warning: Could not read {file_path}: {e}", file=sys.stderr)

    return directory_structure, relevant_contents, third_party_libraries

def main():
    parser = argparse.ArgumentParser(description="Generate a project overview.")
    parser.add_argument(
        "--short",
        action="store_true",
        default=False,
        help="Include only function names/docstrings for Python files."
    )
    # Positional arguments for file paths to exclude from shortening when using --short.
    parser.add_argument(
        "exclude_files",
        nargs="*",
        default=[],
        help="List of file paths (relative to the project root) to exclude from shortening when using --short."
    )
    parser.add_argument(
        "--skip",
        nargs="*",
        default=[],
        help="List of directories or file paths (relative to the project root) to skip entirely."
    )
    args = parser.parse_args()

    if not args.short and args.exclude_files:
        print("Warning: Exclude file arguments are ignored when not using --short.")

    root_path = Path(__file__).parent.resolve()
    print(f"Traversing directory: {root_path}")

    directory_structure, relevant_contents, third_party_libraries = traverse_directory(
        root_path,
        short_version=args.short,
        exclude_files=args.exclude_files,
        skip_paths=args.skip
    )

    # Write overview to project_overview.txt.
    output_file = root_path / "project_overview.txt"
    with output_file.open('w', encoding='utf-8') as f:
        # Write the prompt text.
        f.write(PROMPT_TEXT)
        f.write("\n=== Directory Structure ===\n")
        f.write("\n".join(directory_structure))
        f.write("\n\n=== Consolidated Documentation ===\n")
        f.write("\n".join(relevant_contents))

    print(f"Overview has been written to {output_file}")

    # Write discovered third-party libraries to requirements_autogenerated.txt.
    sorted_libs = sorted(third_party_libraries)
    req_file = root_path / "requirements_autogenerated.txt"
    with req_file.open('w', encoding='utf-8') as f:
        for lib in sorted_libs:
            f.write(lib.lower() + "\n")

    print(f"Auto-generated requirements saved to {req_file}")

if __name__ == "__main__":
    main()


=== Content of ./project_query.py ===
import os
import json
import argparse
import tiktoken
import random
from pathlib import Path

# Load configuration from config/config.json
def load_config():
    config_path = os.path.join("config", "llm_config.json")
    try:
        with open(config_path, 'r', encoding='utf-8') as f:
            config = json.load(f)
        return config
    except Exception as e:
        print(f"Error loading config from {config_path}: {e}")
        return {}

# Initialize tiktoken encoder (using a common encoding; adjust as needed)
ENCODING = tiktoken.get_encoding("cl100k_base")

def count_tokens(text):
    """Count tokens in text using tiktoken."""
    return len(ENCODING.encode(text))

def load_project_background():
    """
    Loads the main README.md file as the project background.
    If reading fails, returns a fallback message.
    """
    readme_path = Path(__file__).parent / "README.md"
    try:
        with open(readme_path, 'r', encoding='utf-8') as f:
            return f.read().strip()
    except Exception as e:
        print(f"Error loading project background from {readme_path}: {e}")
        return "Project background not available."

PROJECT_BACKGROUND = load_project_background()

# Define a prompt template that includes the dynamically loaded project background.
PROMPT_TEMPLATE = f"""
Project Background:
{PROJECT_BACKGROUND}

User Query:
{{user_prompt}}
"""

def build_prompt_header(user_prompt):
    """Construct the full prompt header using the template."""
    return PROMPT_TEMPLATE.format(user_prompt=user_prompt).strip() + "\n\n"

def gemini_assess_file(content, user_prompt, config):
    """
    Calls the Gemini API via the google.genai package to determine if the entire file is relevant or should be summarized.
    
    The prompt instructs the model as follows:
      - If the whole file is relevant, respond exactly with "RELEVANT".
      - Otherwise, respond with "SUMMARY: {your summary}".
    
    Returns:
        A tuple (decision, processed_text) where:
          - decision is "include_whole" if the file should be included in full,
            or "summarize" if a summary is provided.
          - processed_text is None for "include_whole" or contains the summary text for "summarize".
    """
    # Retrieve API key and model from config or environment
    api_key = config.get("GEMINI_API_KEY") or os.getenv("GEMINI_API_KEY")
    model = config.get("DEFAULT_MODEL", "gemini-2.0-flash")
    
    try:
        from google import genai
        client = genai.Client(api_key=api_key)
    except ImportError:
        print("Gemini API package not found. Gemini provider will be disabled.")
        # Fallback: decide based on length (this is a simple fallback behavior)
        if len(content.split()) > 300:
            return ("summarize", content[:1000])
        else:
            return ("include_whole", None)
    
    # Build the prompt with clear instructions.
    prompt = (
        f"{user_prompt}\n\n"
        "You are an expert content analyzer for a complex technical project. Read the following content, and compare the content to the user query:\n\n"
        f"{content}\n\n"
        "If the entire file is relevant to the user query and should be included in full, respond with exactly 'RELEVANT'. "
        "Otherwise, if the file is too long or contains information that is better summarized, "
        "provide a brief summary. Your response must begin with 'SUMMARY:' followed by your summary in a few sentences."
    )
    retries = 3  # Maximum number of retries on rate limit errors
    while retries > 0:
        try:
            response = client.models.generate_content(
                model=model,
                contents=[prompt]
            )
            result_text = response.text.strip()
            
            if result_text.upper().startswith("RELEVANT"):
                return ("include_whole", None)
            elif result_text.upper().startswith("SUMMARY:"):
                summary = result_text[len("SUMMARY:"):].strip()
                return ("summarize", summary)
            else:
                print("Unexpected Gemini response:", result_text)
                return ("summarize", content[:1000])
        except Exception as e:
            error_message = str(e).lower()
            # Check for rate limit error indicators: 429 status code or RESOURCE_EXHAUSTED keyword
            if "429" in error_message or "resource_exhausted" in error_message:
                print("Rate limit exceeded. Waiting 60 seconds before retrying...")
                import time
                time.sleep(60)
                retries -= 1
                continue  # Try the request again
            else:
                print("Error calling Gemini API:", e)
                return ("summarize", content[:1000])
        
# Example integration into our file processing logic
def model_assess_file(content, prompt, config):
    """
    Uses the Gemini API to decide whether to include the whole file or summarize it.
    The 'prompt' parameter can be used to inject additional context if needed.
    """
    decision, processed_content = gemini_assess_file(content, prompt, config)
    return decision, processed_content

def process_file(file_path, user_prompt, config):
    """
    Reads a file, assesses its relevance using Gemini, and returns its processed content with a header.
    """
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
    except Exception as e:
        print(f"Error reading {file_path}: {e}")
        return None

    decision, processed_content = model_assess_file(content, user_prompt, config)
    if decision == "skip":
        return None

    header = f"--- File: {file_path} ---\n"
    if decision == "include_whole":
        return header + content + "\n\n"
    elif decision == "summarize":
        return header + processed_content + "\n\n"
    else:
        # In case of unexpected decision, fallback to summarizing.
        return header + content[:1000] + "\n\n"

def traverse_and_collect(directory, user_prompt, token_limit, config):
    """
    Traverses the given directory, processes files based on relevance, and appends their content
    (prefaced with a detailed prompt header) until the token limit is reached.
    """
    prompt_header = build_prompt_header(user_prompt)
    collected_text = prompt_header
    token_count = count_tokens(collected_text)
    
    for root, dirs, files in os.walk(directory):
        for file in files:
            file_path = os.path.join(root, file)
            file_text = process_file(file_path, user_prompt, config)
            if file_text is None:
                continue
            new_tokens = count_tokens(file_text)
            if token_count + new_tokens > token_limit:
                print("Token limit reached. Stopping collection.")
                return collected_text
            collected_text += file_text
            token_count += new_tokens

    return collected_text

def main():
    parser = argparse.ArgumentParser(
        description="Attach a prompt header and collect relevant project text within a token limit."
    )
    parser.add_argument("--directory", type=str, default=".", help="Directory to traverse.")
    parser.add_argument("--prompt", type=str, required=True, 
                        help="User prompt (e.g., 'Find all files relevant to constructing large scale land battles.')")
    parser.add_argument("--token_limit", type=int, default=100000, 
                        help="Maximum number of tokens allowed in the output.")
    args = parser.parse_args()

    config = load_config()
    output_text = traverse_and_collect(args.directory, args.prompt, args.token_limit, config)
    print("=== OUTPUT ===")
    print(output_text)

if __name__ == "__main__":
    main()


=== Content of ./README.md ===
# Tabletop RPG of Influence & Strategic Command

## Overview
This project aims to create a revolutionary tabletop role-playing game (RPG) that fuses detailed character-driven narrative with expansive strategic simulation. Unlike traditional RPGs that focus solely on adventuring, our game places players in the roles of high-status figures—such as military leaders, political masterminds, corporate magnates, and cultural icons—who wield influence over vast social, economic, and military domains. Players will experience both the intricate personal development typical of RPGs and the large-scale decision-making found in strategy games.

## Table of Contents
- [Project Vision](#project-vision)
- [Game Mechanics](#game-mechanics)
  - [Military Mechanics](#military-mechanics)
  - [Character Attributes & Creation](#character-attributes--creation)
  - [Risk/Danger System](#riskdanger-system)
- [Procedural Generation & Architecture](#procedural-generation--architecture)
- [Classes & Archetypes](#classes--archetypes)
- [Reference Materials](#reference-materials)
- [Future Extensions](#future-extensions)
- [Development Roadmap](#development-roadmap)
- [Requirements](#requirements)
- [Developer Tools](#developer-tools)

## Project Vision
The game is designed to merge intimate, character-driven role-playing with the high-stakes dynamics of strategic management. Players assume the roles of influential figures—from military commanders and political leaders to CEOs and even deities in fantasy or sci-fi settings—whose personal actions and grand strategic decisions shape the world around them. The core design emphasizes:
- **Dual Layer Gameplay:** Integrating personal narrative with large-scale strategic control.
- **Dynamic Storytelling:** Using AI and procedural generation to create immersive narratives that evolve with player decisions.
- **Modular Design:** A system built with flexibility in mind, allowing future expansion into multiple eras and domains of influence.

## Game Mechanics

### Military Mechanics
- **Hierarchical Command:** Characters begin as low-level officers and can rise to the rank of generals based on tactical acumen and successful command.
- **Dice-Based Combat Resolution:** Battles are resolved with dice rolls that incorporate factors such as terrain, weather, unit morale, and enemy tactics—ensuring that even the best plans are subject to the chaos of war.
- **Strategic Decision-Making:** Beyond individual encounters, players manage logistics, deploy resources, and plan entire campaigns that affect the broader narrative.

### Character Attributes & Creation
Characters are defined by six core attributes that capture the essence of personal influence:
1. **Stature:** The physical legacy and commanding presence of a character.
2. **Charisma:** Natural magnetism and persuasive power.
3. **Tactics:** The ability to devise and execute strategic plans.
4. **Gravitas:** Moral authority and ethical weight that influence social interactions.
5. **Resolve:** Mental toughness and determination under pressure.
6. **Ingenuity:** Creative problem-solving and adaptability.

Each attribute starts at a baseline score of **10**, with modifiers calculated as +1 for every 2 points above (or -1 for every 2 points below) the baseline. The character creation process combines backstory, point allocation, and potential dice-based or point-buy methods to ensure every influential persona is both unique and balanced.

### Risk/Danger System
Instead of traditional hitpoints, the game introduces a dynamic risk or danger system:
- **Risk Levels:** Characters are categorized into four risk states—Low-Risk, Normal, High-Risk, and Critical. If the risk level drops below Critical, the character dies.
- **Variable Check Intervals:** The frequency of risk checks depends on the current risk level (yearly for Low-Risk, monthly for Normal, weekly for High-Risk, and daily for Critical).
- **Outcome Determination:** A dice roll (modified by character attributes and situational factors) determines whether a positive event (improving risk) or a negative event (worsening risk) occurs.
- **Narrative Integration:** Each outcome is enriched with narrative descriptions, blending mechanical events with creative storytelling.

## Procedural Generation & Architecture
The project is built on a robust, modular architecture that leverages AI-driven procedural generation to manage a living, evolving game world:
- **Procedural Generation Engine (PGE):** Dynamically creates game objects (characters, items, locations, events) using modular templates and algorithmic randomness.
- **Object Repository & State Management:** A database system stores each generated object and its evolving history, ensuring persistent and dynamic gameplay.
- **Simulation & Event Engine:** Processes complex simulations—including large-scale battles—by handling numerous dice rolls and event ticks in parallel.
- **AI-Gamemaster Module:** Uses large language models (LLMs) to generate contextual narrative, dialogue, and scene descriptions.
- **Player Interaction Layer:** A text-based interface (or API) through which players issue commands and receive real-time updates.
- **Integration Bus:** An event-driven system, potentially using microservices, for seamless communication among various project components.

## Classes & Archetypes
Players choose from several broad classes that define their path to influence. Each class can be further customized:
1. **Military Leader:** Focuses on battlefield tactics and strategic command.
2. **Political Leader:** Excels in negotiation, governance, and policy-making.
3. **Religious Leader:** Wields spiritual authority and moral influence.
4. **Criminal Overlord:** Commands the underworld with resourcefulness and ruthlessness.
5. **Corporate Magnate:** Dominates industries and economic landscapes.
6. **Innovator:** Drives progress with creative problem-solving and technological breakthroughs.
7. **Cultural Icon:** Influences public opinion and cultural trends.

## Reference Materials
Extensive research and reference files ensure historical and tactical authenticity. These include:
- Detailed naval specifications (e.g., HMS Victory).
- Historical and tactical documents.
- Various drafts and templates for character creation and narrative development.

## Future Extensions
While the initial focus is on modern military mechanics and high-level strategy, future versions will expand the game to include:
- Multiple eras and genres.
- Expanded domains of influence (political, economic, cultural).
- Enhanced AI integration for dynamic storytelling and procedural content generation.

## Development Roadmap
1. **Prototype Development:** Build a basic version of the Procedural Generation Engine and Object Repository.
2. **Integration Testing:** Ensure robust communication between simulation engine, AI-gamemaster, and player interface.
3. **Performance Benchmarking:** Simulate large-scale scenarios to validate scalability.
4. **Iterative Refinement:** Use playtesting feedback to adjust mechanics, thresholds, and narrative integration.
5. **Documentation Consolidation:** Transition to using this README.md as the single source of project truth.

## Requirements
- **Language & Environment:** Python is used for prototyping and system integration.
- **Dependencies:** Managed via the auto-generated `requirements_autogenerated.txt`.
- **AI Integration:** Uses LLM APIs (e.g., Google Gemini) for narrative generation.
- **Database:** A relational or NoSQL database for persistent state management.

## Developer Tools
To further aid in project development, contributors can use the following utilities:

### `generate_project_overview.py`
- **Purpose:**  
  Aggregates the project's directory structure, source code, and documentation into a comprehensive overview (`project_overview.txt`).  
- **Usage:**  
  - **Full Output:** Run without flags for a complete listing of all files and their contents.  
  - **Short Output:** Use the `--short` flag to include only Python function/class signatures and docstrings.  
  - **Exclusions:** Provide additional file paths (relative to the project root) after `--short` to output those files in full.  
  - **Skipping:** Use the `--skip` flag to omit specified directories or files entirely.  
- **Benefit:**  
  Quickly get a snapshot of the entire project’s architecture and documentation, which is especially useful for onboarding new contributors or conducting audits.

### `project_query.py`
- **Purpose:**  
  Constructs a prompt by dynamically loading the project background from `README.md` and combining it with a user query. It then traverses project files to collect and assess relevant content using AI-based summarization or inclusion logic.
- **Usage:**  
  - Provide a user query via the `--prompt` argument to search for specific details across project files.
  - Adjust the `--token_limit` to control the output length.
- **Benefit:**  
  Efficiently gather targeted project information, which is particularly useful during development for troubleshooting, design reviews, or feature planning.

---

Contributors are encouraged to explore these tools as part of the development workflow. They serve as powerful utilities to understand the project structure, assess file relevance, and streamline collaboration on this ambitious RPG project.


=== Content of ./requirements_autogenerated.txt ===
google
tiktoken
wikipedia


=== Content of config/README.md ===
# Config Directory

## LLM configuration settings
- LLM_config.json
This file is currently used to store the credential for Google Gemini. This model is used mainly for project management for the time being.

=== Content of design/function_calling.md ===
**Summary of Function Calling in the Gemini API**

The Gemini API introduces a robust function calling mechanism that allows the language model to not only generate natural language but also output structured instructions that directly invoke pre-defined functions. Here’s a concise overview:

- **Structured Interaction:**  
  The model can output a JSON object specifying which function to call and with what parameters. This structured output enables seamless integration between natural language responses and programmatic actions.

- **Declarative Function Signatures:**  
  Developers define function signatures (including expected parameter types and descriptions). This provides clear guidelines to the model about how and when to use each function, ensuring that calls are made in a controlled and predictable manner.

- **Execution and Feedback Loop:**  
  When the model decides to invoke a function, the calling system executes it and captures the output. This result is then passed back to the model, allowing it to incorporate real-world data and computed results into its subsequent responses. This creates a dynamic feedback loop where the model's reasoning is grounded in actual execution outcomes.

- **Enhanced Safety and Predictability:**  
  By structuring the function calls, the system minimizes ambiguity in interpretation. It ensures that operations performed are type-safe and conform to the developer’s expectations, reducing risks associated with executing arbitrary code.

---

**Background: Why Function Calling is Valuable for Our Role-Playing Game**

In our ambitious tabletop role-playing game project, we build objects from templates—be they characters, events, or in-game items—and each of these objects can have a complex set of properties and behaviors. Integrating a "game master" AI system that interacts with these objects in real time can elevate the gaming experience in several ways:

- **Dynamic Narrative Integration:**  
  The function calling mechanism can empower our game master AI to actively manage and manipulate game objects. For example, upon creating a character or encountering a critical event, the AI can call specific functions to adjust attributes, trigger narrative events, or modify the game state based on both pre-defined rules and emergent gameplay conditions.

- **Real-Time Interaction:**  
  With function calling, the game master AI can immediately respond to players' actions or in-game events by invoking the appropriate functions. This leads to a more immersive and responsive game environment where decisions and outcomes are processed dynamically, providing instant feedback that enhances engagement.

- **Seamless Integration Between Story and Mechanics:**  
  By bridging natural language descriptions and programmatic functions, our system can generate rich, context-specific storytelling while ensuring that all narrative changes are synchronized with underlying game mechanics. The function calling mechanism acts as a translator between the creative narrative and the precise computational logic required for game simulations.

- **Modular and Extensible Design:**  
  Using function calling, developers can easily extend the game’s capabilities by adding new functions for additional mechanics, narrative elements, or interactive behaviors. This modularity makes the game both robust and adaptable to future expansions.

In summary, Gemini’s function calling feature provides a powerful tool for building an interactive, intelligent game master that can dynamically engage with game objects, making our RPG not only more immersive but also more flexible and scalable.

Below is an updated explanation and example that incorporates Google's tutorial details on function calling. In this example, we define a function for our RPG—a function to set a ship to sail—and then show how to declare it as a tool in the generation configuration. Finally, we demonstrate how a captain’s verbal command (e.g., "Captain, set sail toward the Atlantic Ocean!") results in a structured function call that updates the ship's state.

---

## Summary of Function Calling in the Gemini API

The Gemini API’s function calling mechanism enables the language model to output structured JSON that invokes predefined functions in your application. Key points include:

- **Structured Interaction:**  
  Instead of only returning free-form text, the model can output a JSON object that specifies which function to call and with what parameters. This bridges natural language with programmatic actions.

- **Detailed Function Signatures:**  
  By providing detailed descriptions of functions and their parameters, the model is guided to select the correct function and supply valid arguments, ensuring safe and predictable execution.

- **Execution & Feedback:**  
  The application can execute these function calls—invoking internal or external services—and then feed the results back to the model. This creates a feedback loop where the model can refine its responses based on actual function outcomes.

- **Automatic vs. Manual Control:**  
  The Python SDK supports automatic function calling by default, but you can disable it via configuration if you need to handle each call or add extra logic between calls.

---

## Why Use Function Calling for Our Role-Playing Game?

In our RPG project, many objects—such as ships, characters, or events—are created from templates. By integrating function calling:

- **Dynamic Game Master AI:**  
  The "game master" AI can directly interact with in-game objects. For example, when a ship is constructed from its JSON template, the AI can later invoke a function to change its state (e.g., from "docked" to "sailing") based on player commands.

- **Real-Time State Updates:**  
  When a captain gives a verbal command (like setting sail), the system can immediately process the command by calling a function that updates the ship’s state. This ensures that narrative events and mechanical changes stay in sync.

- **Enhanced Immersion and Extensibility:**  
  By bridging narrative commands with structured function calls, players experience a more interactive and responsive game world. Additionally, new functions can be added as the game evolves, making the system modular and extensible.

---

## Hypothetical Example: Setting Sail

### 1. Define the Function to Update a Ship’s State

Below is a Python function that represents setting a ship to sail. In a real system, this function would update the game state; here, it simulates the behavior:

```python
def set_sail(ship_id: str, destination: str) -> dict[str, int | str]:
    """Set the sail for a ship and update its state to reflect that it is now sailing.

    Args:
        ship_id: Unique identifier for the ship.
        destination: The target destination for the ship.
    
    Returns:
        A dictionary containing the updated ship status.
    """
    # In a full implementation, this function would interact with the game state.
    # Here we simulate updating the ship's state.
    updated_ship = {
        "ship_id": ship_id,
        "name": "HMS Victory",
        "status": "sailing",
        "location": "At sea",
        "destination": destination,
        "speed": 15  # Example: cruising speed in knots
    }
    return updated_ship
```

### 2. Declare the Function in the Generation Configuration

We now declare the function as a tool in the Gemini API configuration. This informs the model that it can call `set_sail` when appropriate:

```python
from google.genai import types

# Define the configuration, including the function as a tool.
config = types.GenerateContentConfig(
    tools=[set_sail]
)
```

### 3. Generate a Function Call via the Gemini API

Using the configured tools, we prompt the model with a captain’s command. The model generates a JSON object that calls our `set_sail` function with the appropriate parameters:

```python
from google import genai

client = genai.Client()

# Generate content directly with a function call.
response = client.models.generate_content(
    model='gemini-2.0-flash',
    config=config,
    contents="Captain, set sail toward the Atlantic Ocean!"
)
print(response.text)
```

Alternatively, using the chat interface:

```python
chat = client.chats.create(model='gemini-2.0-flash', config=config)
response = chat.send_message("Captain, set sail toward the Atlantic Ocean!")
print(response.text)
```

In either case, the model’s response might look similar to:

```json
{
  "function": "set_sail",
  "parameters": {
    "ship_id": "hms_victory",
    "destination": "Atlantic Ocean"
  }
}
```

This structured output can then be interpreted by your application to invoke the `set_sail` function, which updates the ship's state accordingly.

### 4. Handling Automatic Function Calling

If you want to handle function calls manually (for example, to interpose additional logic), you can disable automatic function calling:

```python
from google.genai import types

config = types.GenerateContentConfig(
    tools=[set_sail],
    automatic_function_calling=types.AutomaticFunctionCallingConfig(disable=True)
)
```

This configuration lets you inspect the model’s response and decide when and how to execute the function.

---

By integrating this function calling approach, our game system can seamlessly blend narrative commands with concrete state changes—making the gameplay more dynamic and immersive while keeping the underlying logic clear and maintainable.

Let me know if you need further modifications or additional examples!

=== Content of design/README.md ===
# Design Docs

Documentation related to overall design goals.

=== Content of drafts/README.md ===
# Drafts

This directory is entirely for text files that store rough drafts of the game's rules. Expect many more sub-directories to be created here. Final drafts will most likely be written in a more formal text rendering language.

=== Content of drafts\character/attributes_draft_1.txt ===
Below is a first draft of the character creation process for our game. This draft focuses on establishing your character’s core identity and attributes—the foundation upon which all leadership, influence, and strategic decisions will be built.

---

## **Character Creation: First Draft**

### **Step 1: Concept & Background**

Before diving into numbers, take a moment to envision who your character is. Are they a retired military general whose commanding presence still turns heads, a charismatic public figure whose words move nations, or perhaps an innovative entrepreneur who reshaped their industry? Consider the following:

- **Concept:** Write a short description (a few sentences) of your character’s identity, background, and sphere of influence.  
- **Role & Legacy:** Think about how your past has shaped you. Have you got the physical legacy of youth or combat training? Do you rely on persuasive charm, strategic planning, or a distinctive moral stance?  
- **Personal Goals:** Note a few key ambitions or challenges your character might face. These goals will influence how you allocate your strengths later in the process.

### **Step 2: Core Attributes Overview**

Our game uses six core attributes designed to capture the spectrum of influence. These are:

1. **Stature** – The enduring impact of your physical legacy. Even if you’re no longer on the battlefield, your past achievements and physical presence continue to command respect.  
2. **Charisma** – Your natural magnetism and persuasive force, whether in public speaking, media, or one-on-one interactions.  
3. **Tactics** – Your ability to devise and execute effective strategies in complex, high-pressure situations.  
4. **Gravitas** – The ethical weight and moral authority that influence how others perceive and trust you.  
5. **Resolve** – Your inner determination and mental toughness, crucial for enduring setbacks and making hard decisions.  
6. **Ingenuity** – Your capacity for creative problem-solving and innovation—staying ahead in a rapidly changing world.

Each attribute starts with a baseline score of **10**, representing the average level of ability. The numbers above or below 10 will affect the outcome of various challenges and actions in the game.

### **Step 3: Assigning Attribute Scores**

You have a pool of points to distribute among your six attributes. (Note: In future iterations, we can offer multiple methods, such as rolling dice or point-buy systems. For now, assume you have a fixed number of points or a standard array to assign.)

- **Default Value:** Every attribute begins at 10.
- **Customization:** Decide where your character excels and where they might be less dominant. For example, a former soldier might have higher Stature and Tactics, while a media mogul might lean toward Charisma and Ingenuity.

#### **Example:**
Imagine a character who is a charismatic military strategist with a strong ethical core but less emphasis on innovation. Their attribute allocation might look like this:
- **Stature:** 12 (A touch above average, reflecting a commanding presence built on a history of physical training.)
- **Charisma:** 14 (Highly persuasive and influential in social settings.)
- **Tactics:** 16 (Exceptional strategic insight and battlefield acumen.)
- **Gravitas:** 14 (Strong moral authority and ethical influence.)
- **Resolve:** 12 (Good mental toughness and determination.)
- **Ingenuity:** 10 (Average creativity and problem-solving ability.)

### **Step 4: Calculating Modifiers**

For every 2 points your attribute score is above or below the average of 10, your character receives a modifier. This modifier will adjust the results of your dice rolls when you attempt tasks related to that attribute. The calculation is straightforward:

- **Modifier Formula:**  
  \[
  \text{Modifier} = \frac{\text{Attribute Score} - 10}{2} \quad (\text{round down})
  \]

#### **Example Calculations:**

- **Stature (12):**  
  \((12 - 10) / 2 = +1\) modifier.
- **Charisma (14):**  
  \((14 - 10) / 2 = +2\) modifier.
- **Tactics (16):**  
  \((16 - 10) / 2 = +3\) modifier.
- **Gravitas (14):**  
  \((14 - 10) / 2 = +2\) modifier.
- **Resolve (12):**  
  \((12 - 10) / 2 = +1\) modifier.
- **Ingenuity (10):**  
  \((10 - 10) / 2 = +0\) modifier.

These modifiers will come into play during both narrative challenges and strategic conflict resolutions, helping you determine the likelihood of success when you rely on your character’s innate abilities.

### **Step 5: Integrating Your Attributes into Gameplay**

Once you have your attributes and modifiers established, they will influence many aspects of the game:
- **Task Resolution:** When attempting any action related to one of these attributes—whether negotiating a high-stakes deal (Charisma) or planning a complex military maneuver (Tactics)—you’ll roll dice and add the relevant modifier.
- **Narrative Influence:** Your attribute scores help define how other characters perceive you. A high Gravitas might mean that your opinions carry extra weight in political or ethical debates.
- **Strategic Decisions:** In broader strategic scenarios (like managing an organization or leading an army), these attributes will factor into the outcomes of your decisions, affecting both immediate encounters and long-term campaign success.

### **Step 6: Final Touches & Next Steps**

After setting your attributes and calculating your modifiers:
- **Refine Your Background:** Adjust your backstory to reflect the choices you made during attribute allocation. Emphasize why your character is strong in certain areas and perhaps hint at challenges they might face due to lower scores in other aspects.
- **Choose Additional Elements:** In subsequent stages of character creation, you’ll likely select skills, equipment, and other resources that further define your influence. These choices will also interact with your core attributes.
- **Review & Balance:** Ensure that your attribute distribution matches your character concept. Consider how each attribute contributes to your overall narrative and strategic potential.

---

This first draft establishes the basic framework for your character’s creation, from conceptualization to the technical details of attribute scores and modifiers. It lays the foundation for a system where every influential decision, strategic maneuver, or personal interaction is backed by a clear, quantifiable measure of your character’s inherent abilities. Future iterations of the character creation process will expand upon this foundation by incorporating skills, specializations, and additional narrative layers that further bring your influential persona to life.

=== Content of drafts\character/classes_draft_1.txt ===
---

# **Chapter 3: The Influence Archetypes**

In this world of power and persuasion, your influence is your weapon. Whether you command armies, sway the masses, or operate in the shadows, your chosen archetype defines your path to greatness. Below is a first draft of the seven broad classes, each with its own flavor and specialties. Use these as your foundation—and feel free to customize further with sub-classes that match your vision.

---

## **1. Military Leader**

*“Strategy is the art of making use of time and space. I am the master of both.”*  
A Military Leader is forged in the fires of conflict and honed through discipline. Whether rising from the ranks or born into a legacy of valor, these leaders blend tactical brilliance with an unwavering command presence. Even when retired from the front lines, the echoes of their youthful prowess and battlefield glory resonate in every decision they make.

**Signature Traits:**  
- **Tactics:** Masterful in planning, coordinating, and executing strategies on and off the battlefield.  
- **Stature:** Commanding presence that endures long after the dust of battle has settled.  
- **Resolve:** Steadfast mental fortitude to withstand the pressures of leadership.

**Potential Sub-Classes:**  
- **Army General:** The embodiment of land warfare, leading vast legions with precision and courage.  
- **Naval Officer:** Ruling the waves, whether as a line officer, naval aviator, or submarine strategist.  
- **Air Force Commander:** Master of the skies, orchestrating aerial maneuvers that change the tide of battle.  
- **Special Forces Operative:** Elite and enigmatic, operating behind enemy lines with surgical precision.

---

## **2. Political Leader**

*“Power is the ability to shape society—and I shape it every day.”*  
The Political Leader maneuvers through the corridors of power with deft negotiation and astute governance. Whether they rise as a charismatic statesperson or a shrewd bureaucrat, these figures are adept at harnessing public opinion, forging alliances, and bending the political landscape to their will.

**Signature Traits:**  
- **Diplomacy:** The art of negotiation, alliance-building, and conflict resolution.  
- **Authority:** The inherent ability to command respect and loyalty in the halls of power.  
- **Strategic Insight:** Keen intellect that foresees and shapes political trends.

**Potential Sub-Classes:**  
- **Head of State:** A President, Prime Minister, or monarch who steers the destiny of a nation.  
- **Legislator:** A policymaker with the power to craft and influence laws.  
- **Diplomat:** A master negotiator who builds bridges across political divides.  
- **Local Leader:** The trusted official shaping communities from the ground up.

---

## **3. Religious Leader**

*“Faith can move mountains—and my words move hearts.”*  
Religious Leaders command reverence through spiritual authority. Whether serving as a venerable cleric, an enigmatic prophet, or even a controversial cult figure, these individuals channel the power of belief to guide, inspire, and sometimes manipulate the masses. Their influence is measured not only by devotion but by the moral and ethical weight of their words.

**Signature Traits:**  
- **Inspiration:** The ability to evoke deep commitment and fervor in followers.  
- **Mysticism:** An aura of the sacred, blending tradition with the enigmatic.  
- **Moral Gravitas:** A powerful ethical presence that can guide, console, or even intimidate.

**Potential Sub-Classes:**  
- **Cleric:** A traditional spiritual leader with deep roots in faith and doctrine.  
- **Cult Leader:** A charismatic figure who bends dogma to forge a new path.  
- **Prophet:** A visionary whose insights transcend the mundane.  
- **Mystical Advisor:** The secretive counselor wielding ancient wisdom and ritual power.

---

## **4. Criminal Overlord**

*“In the shadows, I am the law. I am the fear. I am the unseen hand that shapes the underworld.”*  
Operating beyond the bounds of conventional society, the Criminal Overlord thrives in the realm of the illicit. With a blend of ruthless ambition and cunning resourcefulness, these figures rule the underground with an iron fist wrapped in velvet. Their influence is marked by loyalty, treachery, and a raw command that even the most disciplined forces fear.

**Signature Traits:**  
- **Intimidation:** The power to instill fear and command obedience without words.  
- **Subterfuge:** Mastery of secrecy, deception, and manipulation.  
- **Resourcefulness:** The ability to turn even the bleakest circumstances into opportunities.

**Potential Sub-Classes:**  
- **Mafia Boss:** The quintessential crime lord, ruling organized crime with calculated ruthlessness.  
- **Gang Leader:** A streetwise commander who unites disparate elements under a single banner.  
- **Smuggling Kingpin:** A shadowy entrepreneur controlling the flow of contraband and illicit trade.  
- **Crime Strategist:** The cerebral architect behind elaborate criminal enterprises.

---

## **5. Corporate Magnate**

*“I don’t just run companies—I shape industries, markets, and the future itself.”*  
The Corporate Magnate is a titan of commerce, using savvy business acumen and unyielding ambition to build empires. Whether steering a multinational conglomerate or revolutionizing an industry, these figures harness the power of capital and innovation to dominate their domains. Their influence is felt not just in boardrooms but in the very fabric of society.

**Signature Traits:**  
- **Vision:** The foresight to identify and capitalize on market trends.  
- **Influence:** The ability to sway consumer behavior, employee morale, and industry standards.  
- **Financial Acumen:** Mastery of the economic levers that drive success.

**Potential Sub-Classes:**  
- **CEO:** The executive leader who defines and drives corporate strategy.  
- **Industrialist:** A powerhouse industrial leader, building empires from raw material to product.  
- **Venture Capitalist:** A risk-taking investor who fuels the next generation of innovation.  
- **Financial Tycoon:** A master of markets and fiscal maneuvers, commanding wealth on an unprecedented scale.

---

## **6. Innovator**

*“I dream, I create, and in my ideas lie the seeds of tomorrow’s revolution.”*  
Innovators are the avant-garde of progress—scientists, inventors, and thought leaders whose ideas break boundaries and redefine the possible. Their brilliance ignites revolutions in technology, science, and art. Operating on the bleeding edge of discovery, they see not just what is, but what could be, and they have the ingenuity to make it so.

**Signature Traits:**  
- **Ingenuity:** The creative spark that leads to groundbreaking innovations.  
- **Analytical Acumen:** The ability to deconstruct complex problems and devise novel solutions.  
- **Curiosity:** An unquenchable thirst for knowledge that drives constant discovery.

**Potential Sub-Classes:**  
- **Scientist:** A researcher whose work paves the way for new paradigms in knowledge.  
- **Professor:** An academic whose theories and teachings shape minds and futures.  
- **Inventor:** A visionary who transforms ideas into tangible breakthroughs.  
- **Tech Pioneer:** A trailblazer at the frontier of modern technology and innovation.

---

## **7. Cultural Icon**

*“I am the voice, the image, the trend—embodying the spirit of our times and inspiring millions.”*  
Cultural Icons capture the collective imagination through art, media, and performance. Their influence transcends the boundaries of industry, resonating deeply with the public consciousness. With a blend of creativity, charisma, and authenticity, they define eras, inspire movements, and leave a lasting imprint on society.

**Signature Traits:**  
- **Charisma:** Magnetic appeal that draws attention and fosters deep connections with audiences.  
- **Creativity:** The raw talent and originality that set trends and break norms.  
- **Public Influence:** A commanding presence that shapes cultural and social narratives.

**Potential Sub-Classes:**  
- **Celebrity:** A star whose every word and action is magnified by the public eye.  
- **Media Mogul:** A powerhouse controlling channels, platforms, and public discourse.  
- **Artist:** A creator whose work transcends mediums and inspires revolutions in thought.  
- **Social Media Influencer:** A digital native who wields virtual power to mobilize communities and set trends.

---

*Embrace your archetype and shape your destiny. The world of influence awaits—where every decision echoes through the corridors of power, and every action can tip the scales of history. Choose your class, define your sub-class, and craft a legacy that will endure through the ages.*

---

=== Content of drafts\character/risk_categories_draft_1.txt ===
Below is a first draft of a mechanical, rule‐based system for your risk/danger mechanic. This draft is written in an algorithmic style (using pseudocode and clear step‐by‐step instructions), and I’ve noted which steps are best served by narrative-based creative input (from players, the game master, or an AI).

---

## **I. Core Concepts & Data Structures**

1. **Risk Levels:**  
   We define four discrete risk levels as follows:
   - **Low-Risk:** Level 3  
   - **Normal:** Level 2  
   - **High-Risk:** Level 1  
   - **Critical:** Level 0  
   
   *Note:* If a character’s risk level drops below Critical (i.e. becomes -1), the character dies.

2. **Risk Check Intervals:**  
   The frequency at which a risk check occurs is determined by the current risk level:
   - **Level 3 (Low-Risk):** Once per **year**  
   - **Level 2 (Normal):** Once per **month**  
   - **Level 1 (High-Risk):** Once per **week**  
   - **Level 0 (Critical):** Once per **day**

3. **Character Object (Partial Example):**

   ```python
   class Character:
       def __init__(self, name, risk_level=3):
           self.name = name
           self.risk_level = risk_level  # 3 = Low-Risk, 2 = Normal, 1 = High-Risk, 0 = Critical
           self.is_alive = True
           # Other attributes (e.g., Resolve, Gravitas) can influence risk modifiers.
   ```

---

## **II. Risk Check Algorithm**

### **A. Scheduling a Risk Check**

Every character should have a scheduled risk check based on their current risk level.

```python
def schedule_risk_check(character):
    # Define the interval based on risk_level
    intervals = {
        3: "1 year",   # Low-Risk
        2: "1 month",  # Normal
        1: "1 week",   # High-Risk
        0: "1 day"     # Critical
    }
    interval = intervals.get(character.risk_level, "undefined")
    # (Implementation Note: Use your game engine's scheduler to call risk_check(character) after 'interval')
    print(f"Scheduled risk check for {character.name} in {interval}.")
```

*— Narrative Input:*  
*The game master or AI may describe the passage of time and any looming sense of danger as the next risk check interval begins.*

### **B. Performing the Risk Check**

At the scheduled time, run the following algorithm:

```python
import random

def risk_check(character):
    if not character.is_alive:
        return  # No checks for dead characters

    # Step 1: Roll the dice (example: 1d10)
    roll = random.randint(1, 10)
    
    # Step 2: Calculate risk modifiers (could be based on attributes, current situation, etc.)
    # For now, we use a placeholder function.
    modifier = calculate_risk_modifier(character)  # Returns an integer value
    total = roll + modifier

    # Step 3: Define thresholds (these numbers can be adjusted during playtesting)
    negative_threshold = 4  # Example: If total <= 4, then a negative event occurs
    positive_threshold = 7  # Example: If total >= 7, then a positive event occurs

    # Step 4: Determine the outcome based on total roll
    if total <= negative_threshold:
        process_negative_event(character, total)
    elif total >= positive_threshold:
        process_positive_event(character, total)
    else:
        process_neutral_event(character, total)
    
    # Step 5: Reschedule the next risk check based on the updated risk level
    schedule_risk_check(character)
```

#### **Supporting Functions:**

1. **Calculating Risk Modifier:**

   This function can incorporate character attributes (like high Resolve or Gravitas) and situational factors.

   ```python
   def calculate_risk_modifier(character):
       # Example: Simple modifier based on character attributes (placeholder)
       # In practice, modifiers could be the sum of bonuses from Resolve, recent actions, etc.
       # For now, return 0 for neutrality.
       return 0
   ```

2. **Processing a Negative Event:**

   ```python
   def process_negative_event(character, total):
       # Lower the risk level by one step
       character.risk_level -= 1
       print(f"[NEGATIVE] {character.name} suffers a negative event (roll: {total}). Risk level decreases to {character.risk_level_description()}.")
       
       # Narrative Generation (GM/AI input):
       # - The game master or AI should generate a description of the negative event.
       #   E.g., “A sudden illness strikes” or “An assassination attempt weakens your defenses.”
       generate_narrative_event(character, "negative", total)
       
       # Check if risk level is below Critical
       if character.risk_level < 0:
           character_die(character)
   ```

3. **Processing a Positive Event:**

   ```python
   def process_positive_event(character, total):
       # Increase the risk level by one step, but cap at Low-Risk (level 3)
       character.risk_level = min(character.risk_level + 1, 3)
       print(f"[POSITIVE] {character.name} benefits from a positive event (roll: {total}). Risk level increases to {character.risk_level_description()}.")
       
       # Narrative Generation (GM/AI input):
       # - The GM or AI creates a narrative for the positive event.
       #   E.g., “A stroke of good fortune brings allies to your side.”
       generate_narrative_event(character, "positive", total)
   ```

4. **Processing a Neutral Event:**

   ```python
   def process_neutral_event(character, total):
       # No change to risk level
       print(f"[NEUTRAL] {character.name} experiences a neutral event (roll: {total}). Risk level remains {character.risk_level_description()}.")
       
       # Optional Narrative:
       # - A brief narrative description may still be provided.
       generate_narrative_event(character, "neutral", total)
   ```

5. **Handling Character Death:**

   ```python
   def character_die(character):
       character.is_alive = False
       print(f"{character.name} has fallen! Risk level dropped below Critical. The character dies.")
       # Narrative generation:
       # - The GM or AI should elaborate on the circumstances of the character’s demise.
       generate_narrative_event(character, "death", None)
   ```

6. **Helper: Risk Level Description**

   It can be helpful to have a method that returns a text description of the current risk level:

   ```python
   def risk_level_description(character):
       descriptions = {
           3: "Low-Risk",
           2: "Normal",
           1: "High-Risk",
           0: "Critical"
       }
       return descriptions.get(character.risk_level, "Undefined")
       
   # You might add this as a method in the Character class:
   Character.risk_level_description = risk_level_description
   ```

7. **Generating Narrative Events:**

   This function is a placeholder that signals where narrative creativity is required.

   ```python
   def generate_narrative_event(character, event_type, roll_total):
       # This function should trigger narrative-based content generation.
       # Depending on your implementation, it could:
       #   - Prompt the game master for a description.
       #   - Call an AI module to generate a detailed narrative.
       #   - Request player input for what happens next.
       #
       # For now, we print a placeholder message.
       if event_type == "negative":
           narrative = f"A negative event occurs (roll: {roll_total}). Describe the setback."
       elif event_type == "positive":
           narrative = f"A positive event occurs (roll: {roll_total}). Describe the boon."
       elif event_type == "neutral":
           narrative = f"Nothing significant happens (roll: {roll_total})."
       elif event_type == "death":
           narrative = "The fatal blow is dealt. Describe the dramatic final moments."
       print(f"Narrative Event for {character.name}: {narrative}")
   ```

---

## **III. Integrating Action-Based Risk Adjustments**

Apart from the periodic risk checks, player actions can have immediate risk consequences. For example:

```python
def apply_action_risk(character, action_description, risk_modifier):
    """
    Adjusts the risk level based on a specific player action.
    :param action_description: A narrative description of the action.
    :param risk_modifier: An integer (positive to improve safety, negative to worsen risk).
    """
    print(f"Action taken: {action_description} (Risk modifier: {risk_modifier})")
    character.risk_level += risk_modifier
    # Clamp risk_level between -1 and 3
    if character.risk_level > 3:
        character.risk_level = 3
    if character.risk_level < -1:
        character.risk_level = -1
    if character.risk_level < 0:
        character_die(character)
    else:
        print(f"{character.name}'s risk level is now {character.risk_level_description()}.")
```

*— Narrative Input:*  
*Here, the player and/or GM can collaboratively decide on the description of the risk-altering event (e.g., “A daring escape reduces your risk temporarily” or “A failed negotiation increases your vulnerability”).*

---

## **IV. Summary Flow**

1. **Initialization:**  
   - Create character(s) with a starting risk level (default is 3, Low-Risk).  
   - Schedule the first risk check using `schedule_risk_check(character)`.

2. **Periodic Risk Check:**  
   - At the designated interval (yearly, monthly, weekly, or daily), run `risk_check(character)`.
   - Roll dice, apply modifiers, and compare against thresholds.
   - Adjust the risk level accordingly:
     - **Negative Outcome:** Decrease risk level by 1 (if already at Critical, death occurs).
     - **Positive Outcome:** Increase risk level by 1 (max at Low-Risk).
     - **Neutral Outcome:** No change.
   - Trigger narrative generation for flavor and context.
   - Reschedule the next risk check based on the updated risk level.

3. **Player-Driven Actions:**  
   - When a player takes a risky or mitigating action, call `apply_action_risk(character, action_description, risk_modifier)`.
   - Adjust the risk level immediately and provide narrative context.

4. **Narrative Generation:**  
   - At key steps (after risk checks, during action adjustments, and on character death), call `generate_narrative_event` to ensure the mechanical events are richly described with narrative input.

---

## **V. Next Steps & Testing**

- **Playtesting:**  
  Adjust thresholds, modifiers, and time intervals based on gameplay testing to ensure that risk changes are dramatic but fair.

- **Integration:**  
  Integrate this system with other game mechanics (e.g., resource management, diplomatic interactions) so that risk is interwoven with broader narrative and strategy.

- **Expansion:**  
  Enhance the narrative generation functions to use templates or AI-driven storytelling that fits your game’s tone.

---

This first-draft algorithm provides a clear, mechanical foundation for a risk-based system that replaces traditional hitpoints. It is designed to be modular and to invite narrative enrichment at critical junctures, ensuring that the gameplay remains both mechanically sound and richly immersive.

=== Content of src/README.md ===
# Sources

Source code related to the actual game itself (Excludes code related to the meta-development of the project itself).

--------------------------------------------------------------------------------

Next steps:

1. Prepare to implement a small prototype server that will allow users to log in and play this text based game. We will implement each file step by step. In your first answer, just produce an outline of what this implementation strategy will be. We will talk about it, and then once we've agreed on a plan I will ask you to start generating the first files. Initially, our game won't have much material to use. But the goal is to build a working prototype engine that will start up a "gamemaster" AI that will be prompted with the story and materials of the game. A user or multiple users can log in to the text engine to begin playing. We will also consider adding "NPC" AI's that play characters separately from the gamemaster AI. The gamemaster will have to manage the story and all of the dice rolls and things like that, as well as make sure that the "system" (the database that stores game histories along with characters, assets and their locations) updates correctly. So the GM AI will have to manage sending commands to other functions as necessary. There will be an "admin" user that has the authority to give instructions to the gamemaster AI during the times at which the game still needs some hand-holding from a human. 